1
00:00:00,000 --> 00:00:00,100

2
00:00:00,100 --> 00:00:01,900
Hablemos sobre rendimiento
de base de datos.

3
00:00:01,900 --> 00:00:05,140
El rendimiento de base de datos
en MongoDB está impulsado

4
00:00:05,140 --> 00:00:08,020
por exactamente lo mismo que
en toda base de datos.

5
00:00:08,020 --> 00:00:13,610
Que es, si va a usar
un índice para resolver

6
00:00:13,610 --> 00:00:15,550
tu consulta o no.

7
00:00:15,550 --> 00:00:18,010
Así que los índices resultan ser
el factor más importante en el

8
00:00:18,010 --> 00:00:19,450
rendimiento de base de datos--

9
00:00:19,450 --> 00:00:22,440
en MongoDB y en bases
de datos relacionales.

10
00:00:22,440 --> 00:00:24,630
Por ello esto será una revisión
para muchos de ustedes, pero deseo

11
00:00:24,630 --> 00:00:26,860
llevarte a través de lo básico
de indexación, lo que es y

12
00:00:26,860 --> 00:00:29,480
por qué es tan efectivo.

13
00:00:29,480 --> 00:00:32,940
Así que si te fijas en MongoDB
o en cualquier otra base de datos,

14
00:00:32,940 --> 00:00:36,310
almacenará sus datos en estos
grandes archivos en disco y esto

15
00:00:36,310 --> 00:00:39,820
supone representar
algún tipo de colección.

16
00:00:39,820 --> 00:00:42,600
No hay ningún orden en particular
para los documentos en el disco,

17
00:00:42,600 --> 00:00:44,130
podría estar en cualquier lugar.

18
00:00:44,130 --> 00:00:45,490
Y si pides un documento en

19
00:00:45,490 --> 00:00:47,030
particular, haces una consulta.

20
00:00:47,030 --> 00:00:51,920
Lo que la base de datos va a
tener que hacer por defecto es

21
00:00:51,920 --> 00:00:55,245
barrer toda la colección
para encontrar los datos.

22
00:00:55,245 --> 00:00:59,650
Ahora, esto se llama un escaneo de
tabla en una base de datos relacional,

23
00:00:59,650 --> 00:01:04,830
y es un escaneo de colección en
MongoDB y esto es la muerte de

24
00:01:04,830 --> 00:01:05,850
tu rendimiento.

25
00:01:05,850 --> 00:01:08,530
No deseas tener que escanear
tu colección completa

26
00:01:08,530 --> 00:01:11,310
para tus datos si el conjunto de
datos es grande porque será

27
00:01:11,310 --> 00:01:13,090
extremadamente lento.

28
00:01:13,090 --> 00:01:15,460
Así que en su lugar
usamos indexación.

29
00:01:15,460 --> 00:01:16,680
Entonces, ¿cómo funciona la indexación?

30
00:01:16,680 --> 00:01:18,670
Bueno, es bastante sencillo.

31
00:01:18,670 --> 00:01:21,320
Si algo está ordenado, como
por ejemplo esta lista está

32
00:01:21,320 --> 00:01:22,500
ordenada alfabéticamente--

33
00:01:22,500 --> 00:01:24,790
"Apple", "Banana", "Kiwi", "Pear".

34
00:01:24,790 --> 00:01:28,370
Y aun si fuera muy larga,
es muy rápido encontrar

35
00:01:28,370 --> 00:01:29,760
algo en la lista--
¿correcto?

36
00:01:29,760 --> 00:01:33,590
Porque puedes usar una
búsqueda binaria para hacerlo.

37
00:01:33,590 --> 00:01:36,270
Por lo que encontrar algo
en una lista ordenada--

38
00:01:36,270 --> 00:01:37,400
en una lista clasificada--

39
00:01:37,400 --> 00:01:38,300
es rápido.

40
00:01:38,300 --> 00:01:42,300
Encontrar algo en una
lista desordenada es lento.

41
00:01:42,300 --> 00:01:45,730
Lo que hacemos es mantener
nuestras claves ordenadas.

42
00:01:45,730 --> 00:01:48,740
Ahora en realidad no las mantenemos
ordenadas linealmente como

43
00:01:48,740 --> 00:01:50,440
esto en MongoDB--

44
00:01:50,440 --> 00:01:52,240
usamos algo llamado
un "B-tree".

45
00:01:52,240 --> 00:01:55,520
Pero conceptualmente, puedes
imaginar algo como esto.

46
00:01:55,520 --> 00:01:59,150
Y si busco por, digamos,
"Banana", puedo buscar

47
00:01:59,150 --> 00:02:05,100
rápidamente, encontrar el elemento
y luego tener un puntero al

48
00:02:05,100 --> 00:02:07,400
documento real
en la colección.

49
00:02:07,400 --> 00:02:11,890
Esta es la clave.

50
00:02:11,890 --> 00:02:14,990
Así, los índices en MongoDB
son listas ordenadas de claves.

51
00:02:14,990 --> 00:02:17,940
Por ejemplo, podrías tener
un índice en "name" y

52
00:02:17,940 --> 00:02:21,230
luego un índice en "hair_color",
y podría ser otro

53
00:02:21,230 --> 00:02:24,190
índice en "dof" ("date of
birth") o algo.

54
00:02:24,190 --> 00:02:26,990
Ahora, el orden es importante
porque conceptualmente la forma

55
00:02:26,990 --> 00:02:30,760
en que el índice está construído
es que "name" estará en el nivel alto.

56
00:02:30,760 --> 00:02:32,090
Así que aquí están mis "names".

57
00:02:32,090 --> 00:02:38,430
Y esto podría ser
"Amy", "John" y "Zoe"--

58
00:02:38,430 --> 00:02:40,750
bueno probablemente
"Zoe" esté por aquí.

59
00:02:40,750 --> 00:02:43,450
Ahora dentro de esto, el
"hair_color" está ordenado

60
00:02:43,450 --> 00:02:45,120
conceptualmente por aquí.

61
00:02:45,120 --> 00:02:52,490
Para todos los elementos de "Amy"
tenemos "Brown hair", "Blonde hair"--

62
00:02:52,490 --> 00:02:54,890
Voy a poner "BL"
para "Blond hair"--

63
00:02:54,890 --> 00:02:58,130
"Black hair" y luego repito
esto para cada elemento.

64
00:02:58,130 --> 00:03:02,370
Así que habrá algún "Brown hair"
aquí, "Black hair" aquí.

65
00:03:02,370 --> 00:03:04,490
Y entonces finalmente dentro de esto--

66
00:03:04,490 --> 00:03:06,850
podría escoger un color--

67
00:03:06,850 --> 00:03:10,400
podrías tener un montón de
elementos para "date of birth".

68
00:03:10,400 --> 00:03:13,590
Así que está mi "hair_color" por
aquí, mi "name" está en el alto

69
00:03:13,590 --> 00:03:17,450
nivel y luego finalmente obtengo
este elemento "date of birth"

70
00:03:17,450 --> 00:03:19,670
debajo.

71
00:03:19,670 --> 00:03:22,350
Así que si me provees
de la persona--

72
00:03:22,350 --> 00:03:23,620
sólo un nombre--

73
00:03:23,620 --> 00:03:27,380
entonces puedo ir al índice y
puedo encontrar todo de "John".

74
00:03:27,380 --> 00:03:29,640
Y si prefieres proveerme el
"hair_color", puedo descender

75
00:03:29,640 --> 00:03:32,070
y encontrar todas las
personas con "Brown hair".

76
00:03:32,070 --> 00:03:34,890
Y en la parte inferior de esto,
por supuesto, van a ser

77
00:03:34,890 --> 00:03:37,100
punteros a los datos reales.

78
00:03:37,100 --> 00:03:39,660

79
00:03:39,660 --> 00:03:42,950
Ahora, estas cosas van a
representar claves en el documento

80
00:03:42,950 --> 00:03:46,700
de Mongo que hemos
decidido indexar.

81
00:03:46,700 --> 00:03:50,160
Para que una base de datos
utilice un índice, tienes que

82
00:03:50,160 --> 00:03:53,040
darle el conjunto de elementos que
coinciden más por el lado izquierdo.

83
00:03:53,040 --> 00:03:56,280
Sí que puedes darle apenas el
"name" o puedes darle sólo un

84
00:03:56,280 --> 00:03:57,260
"hair_color"--

85
00:03:57,260 --> 00:03:58,800
"name" y el "hair_color"--

86
00:03:58,800 --> 00:03:59,990
o puedes darle el "name",
el "hair_color"

87
00:03:59,990 --> 00:04:01,100
y "dof" (date of birth).

88
00:04:01,100 --> 00:04:04,340
Si provees sólo el "dof",
no puedes hacer mucho

89
00:04:04,340 --> 00:04:07,220
conceptualmente con el índice,
porque "dof" está aquí

90
00:04:07,220 --> 00:04:08,460
abajo en este nivel.

91
00:04:08,460 --> 00:04:12,060
Así que tendrías que hacer una
búsqueda binaria por aquí, luego

92
00:04:12,060 --> 00:04:14,775
una búsqueda binaria a través de esto,
y luego hacer una búsqueda binaria

93
00:04:14,775 --> 00:04:17,329
a través de esto--
etcétera, etcétera, etcétera.

94
00:04:17,329 --> 00:04:20,470
En cambio, necesito
iniciar por arriba.

95
00:04:20,470 --> 00:04:24,420
Y esto es cierto o haciendo
una consulta o haciendo una

96
00:04:24,420 --> 00:04:28,540
actualización o haciendo un
ordenamiento porque "sort" también

97
00:04:28,540 --> 00:04:31,120
usará un índice para
ordenar estos valores.

98
00:04:31,120 --> 00:04:34,750
Así por ejemplo, si saco
un montón de datos de la

99
00:04:34,750 --> 00:04:37,000
colección y deseo
ordenarlos por "name"--

100
00:04:37,000 --> 00:04:40,400
bueno, la base de datos puede
usar este índice si definimos

101
00:04:40,400 --> 00:04:43,440
"name", "hair_color", "dof"
para hacer el ordenamiento.

102
00:04:43,440 --> 00:04:46,600
Ahora, otro punto que deseo
hacer es que cada vez que

103
00:04:46,600 --> 00:04:51,140
la base de datos desee
insertar algo en ella--

104
00:04:51,140 --> 00:04:52,190
o deseas insertar algo en

105
00:04:52,190 --> 00:04:53,530
la base de datos, más bien--

106
00:04:53,530 --> 00:04:57,590
este índice necesita ser
actualizado y esa actualización

107
00:04:57,590 --> 00:04:58,690
toma tiempo.

108
00:04:58,690 --> 00:05:02,280
Así que, aunque las lecturas son
rápidas en la base de datos, las

109
00:05:02,280 --> 00:05:05,920
escrituras son un poco más lentas
si tienes un índice, porque el

110
00:05:05,920 --> 00:05:07,500
índice necesita ser actualizado.

111
00:05:07,500 --> 00:05:09,400
Y por ello los índices
no son sin coste.

112
00:05:09,400 --> 00:05:12,430
Ellos toman espacio en
disco y también toman

113
00:05:12,430 --> 00:05:13,680
tiempo para mantenerlos
actualizados.

114
00:05:13,680 --> 00:05:14,940
Y eso es algo para
tener en mente.

115
00:05:14,940 --> 00:05:18,800
Por ello si no deseas tener ningún
índice en todas las formas

116
00:05:18,800 --> 00:05:21,200
posibles que vas a consultar en
la colección, en su lugar deseas

117
00:05:21,200 --> 00:05:24,760
tener un índice en las formas
que es más probable consultar

118
00:05:24,760 --> 00:05:26,090
la colección.

119
00:05:26,090 --> 00:05:27,660
Vayamos a través de
uno o dos ejemplos--

120
00:05:27,660 --> 00:05:29,050
para hablar acerca de índices.

121
00:05:29,050 --> 00:05:34,946
Digamos que tengo un índice
"a, b, c" y hago una consulta en "b".

122
00:05:34,946 --> 00:05:36,300
¿Se puede usar el índice?

123
00:05:36,300 --> 00:05:38,120
La respuesta es no.

124
00:05:38,120 --> 00:05:40,500
Si hago una consulta sobre "a", sí.

125
00:05:40,500 --> 00:05:42,905
Si hago una consulta sobre "c", no.

126
00:05:42,905 --> 00:05:46,910
Si hago una consulta sobre
"a, b", sí, usa dos

127
00:05:46,910 --> 00:05:48,400
partes del índice.

128
00:05:48,400 --> 00:05:50,090
"a, c"--

129
00:05:50,090 --> 00:05:53,730
esto sólo usa la parte "a" e
ignora la parte "c" para los

130
00:05:53,730 --> 00:05:56,470
propósitos de hacer la
consulta en el índice.

131
00:05:56,470 --> 00:05:58,190
Así que espero que esto
te de una pista.

132
00:05:58,190 --> 00:06:01,250
Muy bien, ahora es tiempo para
nuestro primer cuestionario.

133
00:06:01,250 --> 00:06:03,390
¿Qué optimización
suele tener el mayor

134
00:06:03,390 --> 00:06:05,350
impacto en el rendimiento
de una base de datos?

135
00:06:05,350 --> 00:06:08,120
Añadir más memoria de modo que la
carga de trabajo se ajusta a la memoria,

136
00:06:08,120 --> 00:06:10,570
Añadir un disco más rápido de modo
que la operación que alcanza al disco

137
00:06:10,570 --> 00:06:13,650
será mucho más rápida.
Reemplazar tu procesador con uno

138
00:06:13,650 --> 00:06:16,380
más rápido-- digamos
2 veces más rápido--

139
00:06:16,380 --> 00:06:20,630
O añadir un índice apropiado
en una colección grande de modo que

140
00:06:20,630 --> 00:06:22,640
sólo un pequeño porcentaje de las
consultas necesitan escanear la

141
00:06:22,640 --> 00:06:23,890
colección.

142
00:06:23,890 --> 00:06:24,190
